//PROMISES

//функции-исполнители

//В конструктор Promise передаем функцию-испольнитель и в результате с конструтора возвращается обьект с внутренними свойствами:
// 1) state - сначала pending, потом меняется на fulfilled при вызлве resolve или rejected при вызове reject
// 2) result  - вначале undefined, потом изменяется на value при resolve(value) и на error в случае reject
// Функция исполнитель запускается автоматически при создании промиса , выполняет работу, а затем выполняет один из 2 коллбеков, которые предоставляет js
// но мы  прописываем их вызов - resolve(value)/reject(error), error - обьект ошибки,эти коллбеки просто переводят сотояние обьекта и меняют result
// В результате исполнения может быть что-то одно: или resolve или reject, функция resolve/reject ожидает только один аргумент (или ни одного). Все дополнительные аргументы будут проигнорированы.
const p = new Promise((resolve, reject) => {
    // resolve(123);
    reject(new Error('Something went wrong'))
});

console.log(p.state);
//Свойства state и result – это внутренние свойства объекта Promise и мы не имеем к ним прямого доступа. Для обработки результата следует использовать методы .then/.catch/.finally

//функцит потребители
// 1)then - принимает 2 аргумента(функции): 1 выполнится в результате успешного выполнения, вторая в случае ошибки
p.then(result => console.log(result), (error) => console.log(error));
// 2) catch - если мы хотели бы только обработать ошибку, то можно использовать null в качестве первого аргумента: .then(null, errorHandlingFunction). Или можно воспользоваться методом .catch(errorHandlingFunction), который сделает тоже самое:
p.catch((error) => console.log(error));
// 3) finally - выполнится в любом случае, когда промис завершится: успешно или с ошибкой
// p.finally(() => console.log('промис завершен')); // обработчик, вызываемый из finally, не имеет аргументов, а так же пропускает результ или ошибку дальше к последующему результату

