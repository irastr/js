
//анонимная функция: function() {}

//

//отличие обьявлений функций
//functions declaration
function do1() {}
//function expression - нельзя вызвать функцию до обьявления и в строгом режиме, когда Function Declaration находится в блоке {...}, функция доступна везде внутри блока. Но не снаружи него.
//function expression могут использоваться для динамического создания function() { alert('hi')} и так же стрелочные () => alert('Привет')
//Если нет явной причины использовать Function Expression – предпочитайте Function Declaration, читаемость лучше
const do2 = function() {};


//стрелочная функция отличается:
// у нее нет this, его значение берется снаружи => нельзя использовать с new, не могут быть использованы как конструкторы
// у нее нет переменной arguments
// так же у них нет super

const do3 = () => {
};

//если нет оператора return, функция возвращает undefined

//параметры по умолчанию
function showMessage(from, text = "текст не добавлен") {
    console.log( from + ": " + text );
}

showMessage('Ira');

//РЕКУРСИЯ

//через цикл

const pow2 = (number, pow) => {
    let result = 1;
    for (let i = 0;i < pow; i++) {
        result = result*number
    }
    return result
};

console.log(pow2(2,2));

//рекурсивно

function pow(x, n) {
    if (n === 1) {
        return x; //база рекурсии потому что сразу же приводит к очевидному результату
    } else {
        return x * pow(x, n - 1); //шаг рекурсии: мы сводим задачу к более простому действию (умножение на x) и более простой аналогичной задаче (pow с меньшим n). Последующие шаги упрощают задачу всё больше и больше, пока n не достигает 1.

    }
}

console.log(pow(2, 3) );

/*pow(2, 4) = 2 * pow(2, 3)
pow(2, 3) = 2 * pow(2, 2)
pow(2, 2) = 2 * pow(2, 1)
pow(2, 1) = 2*/

//Общее количество вложенных вызовов (включая первый) называют глубиной рекурсии. В нашем случае она будет равна ровно n.

//КОНТЕКСТ ВЫПОЛНЕНИЯ, СТЕК

//контекст вып. функции.: аргументы с которыми вызывалась функция и конкретное место в коде, на котором находится интепритатор(именно выполнение, не вызов функции), а так же значение this и прочую служебную инфу

//this - объект перед точкой

/*  Когда функция производит вложенный вызов, происходит следующее:
    Выполнение текущей функции приостанавливается.
    Контекст выполнения, связанный с ней, запоминается в специальной структуре данных – стеке контекстов выполнения.
    Выполняются вложенные вызовы, для каждого из которых создаётся свой контекст выполнения.
    После их завершения старый контекст достаётся из стека, и выполнение внешней функции возобновляется с того места, где она была остановлена.*/


// 1 1 2 3 5 8 13 21

const fib0 = (number) => {
    const array = [1, 1];
    for (let i = 2; i < number; i++) {
        array.push((array[i-1] + array[i-2]))
    }
    return array[number -1]
};

console.log(fib0(6)); //8

const fib1 = (number) => {
    let a = 1;
    let b = 1;
    for (let i = 3; i <= number; i++) {
        let c = a + b;
        a = b;
        b = c;
    }
    return b
};

console.log(fib1(4));

// function fib2(n) {
//     return n <= 1 ? n : fib2(n - 1) + fib2(n - 2);
// }

const fib2 = (n) => {
    if (n <= 1) {
        return n
    } else {
        return fib2(n - 1) + fib2(n - 2)
    }
};

console.log( fib2(4));




// const getNumber = (n) => {
//     let a = 1;
//     let b = 1;
//     for (let i = 3; i <= n; i++) {
//         let c = a + b;
//         a = b;
//         b = c;
//     }
//     return b
// };
//
// console.log(getNumber(2))



// РЕКУРСИВНЫЕ ОБХОДЫ

/*
let company = { // тот же самый объект, сжатый для краткости
    sales: [{name: 'John', salary: 1000}, {name: 'Alice', salary: 600 }],
    development: {
        sites: [{name: 'Peter', salary: 2000}, {name: 'Alex', salary: 1800 }],
        internals: [{name: 'Jack', salary: 1300}]
    }
};

// Функция для подсчёта суммы зарплат
function sumSalaries(department) {
    if (Array.isArray(department)) { // случай (1)
        return department.reduce((prev, current) => prev + current.salary, 0); // сумма элементов массива
    } else { // случай (2)
        let sum = 0;
        for (let subdep of Object.values(department)) {
            sum += sumSalaries(subdep); // рекурсивно вызывается для подотделов, суммируя результаты
        }
        return sum;
    }
}

alert(sumSalaries(company)); // 6700
*/


//РЕКУРСИВНЫЕ СТРУКТУРЫ
//связанный список: если нужна быстрая вставка/удления элементов с начала массива
//value,
// next – свойство, ссылающееся на следующий элемент связанного списка или null, если это последний элемент.






//sumTo(n)

const sumTo = (n) => {
    let summ = 0;
    for (let i = 1; i <= n; i++) {
        summ = summ + i;
        console.log(i)
    }
    return summ
};

console.log(sumTo(20));
//1 2 3
//1 2 3 4 5

//sumTo(n) = n + sumTo(n-1) for n > 1


// const sumTo1 = (n) => {
//     if(n>1) {
//         return n + sumTo(n - 1)
//     } else {
//         return n
//     }
// };

const sumTo2 = (n) => {
    if (n === 1) return 1;
    return n + sumTo(n - 1);
};

console.log(sumTo2(20));

const factorial = (n) => {
    // return n === 1 ? n : n * factorial(n - 1)
    if (n === 1) {
        return n
    } else {
        return n * factorial(n - 1)
    }
};

console.log(factorial(3));
// 3*2*1 = 6
// 4*3*2*1 = 24


//Остаточные параметры и оператор расширения

const dance = (first, ...moves) => {
    // console.log(moves); // without first [1, 2, 3]
    console.log(first, moves)// 1 [2, 3] собирает оставшиеся аргументы в массив
};
dance(1,2,3);

//Все аргументы функции находятся в псевдомассиве arguments под своими порядковыми номерами.
//более устарелый способ, стрелочные функции не имеют arguments
function danceAgain() {
    console.log(arguments[0])// 1
}
danceAgain(1,2,3);

//Оператор расширения - наоборот из массива делает список
let arr = [3, 5, 1];
console.log( Math.max(...arr) ); // 5 (оператор "раскрывает" массив в список аргументов)


const str = 'Ira';
console.log(Array.from(str));
console.log(str.split(''));


//ЗАМЫКАНИЕ
//Лесическое окружение функции - есть у каждой выполняемой функции в виде скрытого обьекта: все локальные переменные, которые хранятся в обьекте как свойства
// this +  ссылка на внешнее лексическое окружение


//Function Declaration - в отличии от переменных let они  полностью инициализируются не тогда, когда выполнение доходит до них, а раньше, когда создаётся лексическое окружение.


//Если переменная не была найдена, это будет ошибкой в strict mode. Без strict mode, для обратной совместимости, присваивание несуществующей переменной создаёт новую глобальную переменную с таким именем.


//Функция получает текущее значение внешних переменных, то есть, их последнее значение
// Старые значения переменных нигде не сохраняются. Когда функция хочет получить доступ к переменной, она берёт её текущее значение из своего или внешнего лексического окружения.

let name = "John";

function sayHi() {
    return "Hi, " + name;
}

name = "Pete"; // (*)

console.log(sayHi()); // Pete

//!!новое лексическое окружение функции создаётся каждый раз, когда функция выполняется.


//Что ещё интереснее, вложенная функция может быть возвращена: либо в качестве свойства нового объекта (если внешняя функция создаёт объект с методами), либо сама по себе. И затем может быть использована в любом месте. Не важно где, она всё так же будет иметь доступ к тем же внешним переменным.

// функция-конструктор возвращает новый объект
function User(name) {

    // методом объекта становится вложенная функция
    this.sayHi = function() {
        console.log(name);
    };
}

let user = new User("John");
user.sayHi(); // у кода метода "sayHi" есть доступ к внешней переменной "name"

//внешней - оно находится во внутреннем лекс окружении внутренний функции, доступа к которому у нее нет ? откуда она ее берет ?
//так же тут:

function makeCounter() {
    let count = 0;

    return function() {
        return count++; // есть доступ к внешней переменной "count"
    };
}

let counter = makeCounter();

console.log( counter() ); // 0
console.log( counter() ); // 1
console.log( counter() ); // 2

















//запись методов в обьектах/классах
const obj = {
    sayHi: function() {
        console.log('hi')
    }
};
//сокращенный способ:
const ob2 = {
    sayHi() {
        console.log('hi')
    }
};

//эти две записи не полностью эквивалентны. Есть тонкие различия, связанные с наследованием объектов.
//в классах - работает только 2 способ, в функциях через this. первый


function sayHi() {   // (1) создаём
                     // alert( "Привет" );
}
let func = sayHi;    // (2) копируем
func(); // Привет    // (3) вызываем копию (работает)!
sayHi(); // Привет   //     прежняя тоже работает (почему бы нет)
//Обратите внимание (ещё раз): нет круглых скобок после sayHi. Если бы они были, то выражение func = sayHi() записало бы результат вызова sayHi() в переменную func, а не саму функцию sayHi.
//Нет необходимости в ; в конце блоков кода и синтаксических конструкций, которые их используют, таких как if { ... }, for { }, function f { } и т.д.


